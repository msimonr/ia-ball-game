{"version":3,"sources":["utilities.js","App.js","index.js"],"names":["drawRect","detections","ctx","circle","fillStyle","beginPath","arc","x","y","r","Math","PI","fill","forEach","prediction","width","height","text","score","floor","strokeStyle","font","scale","fillText","lineWidth","rect","stroke","colision","elem","rx","ry","rw","rh","testX","testY","sqrt","pow","drawLose","video","box","drawImage","toque","undefined","id","App","webcamRef","useRef","canvasRef","runCoco","a","cocossd","net","setInterval","detect","current","readyState","videoWidth","videoHeight","getContext","obj","clearInterval","dx","dy","speed","useEffect","className","ref","muted","style","position","marginLeft","marginRight","left","right","textAlign","zindex","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"qbAAaA,EAAW,SAACC,EAAYC,EAAKC,GAEtCD,EAAIE,UAAY,YAChBF,EAAIG,YACJH,EAAII,IAAIH,EAAOI,EAAGJ,EAAOK,EAAGL,EAAOM,EAAG,EAAG,EAAEC,KAAKC,GAAI,GACpDT,EAAIU,OAEJX,EAAWY,SAAQ,SAAAC,GAAY,kBAEGA,EAAU,KAFb,GAEpBP,EAFoB,KAEjBC,EAFiB,KAEdO,EAFc,KAEPC,EAFO,KAGrBC,EAAOH,EAAU,MACjBI,EAAQR,KAAKS,MAA0B,IAApBL,EAAU,OAInCZ,EAAIkB,YADU,QAEdlB,EAAImB,KAAO,aACXnB,EAAIE,UAHU,QAMdF,EAAIG,YACJH,EAAIoB,OAAO,EAAE,GACbpB,EAAIqB,SAASN,EAAM,IAAKC,EAAQ,KAAMH,EAAMR,EAAGC,GAC/CN,EAAIoB,OAAO,EAAE,GACbpB,EAAIsB,UAAY,EAChBtB,EAAIuB,KAAKlB,EAAGC,EAAGO,EAAOC,GACtBd,EAAIwB,aAICC,EAAW,SAAC1B,EAAYE,GAAU,IAAD,gBACzBF,GADyB,IAC1C,2BAA4B,CAAC,IAApB2B,EAAmB,QACxB,GAAqB,WAAlBA,EAAI,OAA0BA,EAAI,MAAY,GAAI,CACjD,IAAIC,EAAKD,EAAI,KAAS,GAClBE,EAAKF,EAAI,KAAS,GAClBG,EAAKH,EAAI,KAAS,GAClBI,EAAKJ,EAAI,KAAS,GAClBK,EAAQ9B,EAAOI,EACf2B,EAAQ/B,EAAOK,EAqBnB,GAnBIL,EAAOI,EAAIsB,EACXI,EAAQJ,EAGH1B,EAAOI,EAAIsB,EAAGE,IACnBE,EAAQJ,EAAGE,GAGX5B,EAAOK,EAAIsB,EACXI,EAAQJ,EAGH3B,EAAOK,EAAIsB,EAAGE,IACnBE,EAAQJ,EAAGE,GAIAtB,KAAKyB,KAAMzB,KAAK0B,IAAKjC,EAAOI,EAAE0B,EAAQ,GAAKvB,KAAK0B,IAAKjC,EAAOK,EAAE0B,EAAQ,IAEzE,GAAK/B,EAAOM,EACrB,OAAOmB,IA9BwB,gCAqCjCS,EAAW,SAACC,EAAOC,EAAKrC,EAAKC,GACtCD,EAAIsC,UAAUF,EAAO,EAAG,GADyB,kBAEnBC,EAAG,KAFgB,GAE1ChC,EAF0C,KAEvCC,EAFuC,KAEpCO,EAFoC,KAE7BC,EAF6B,KAKjDd,EAAIkB,YADU,MAEdlB,EAAImB,KAAO,kBACXnB,EAAIE,UAHU,MAKdF,EAAIG,YACJH,EAAIoB,OAAO,EAAE,GACbpB,EAAIqB,SAAS,cAAYhB,EAAEQ,EAAOP,EAAE,GACpCN,EAAIoB,OAAO,EAAE,GACbpB,EAAIsB,UAAY,EAChBtB,EAAIuB,KAAKlB,EAAGC,EAAGO,EAAOC,GACtBd,EAAIwB,SAEJxB,EAAIE,UAAY,YAChBF,EAAIG,YACJH,EAAII,IAAIH,EAAOI,EAAGJ,EAAOK,EAAGL,EAAOM,EAAG,EAAG,EAAEC,KAAKC,GAAI,GACpDT,EAAIU,QC3EJ6B,OAAQC,EACRC,OAAKD,EACLvC,EAAS,CAAC,EAAK,EAAG,EAAI,EAAG,EAAI,GAAI,GAAK,EAAG,GAAK,EAAG,MAAQ,IA4H9CyC,MA1Hf,WACE,IAAMC,EAAYC,iBAAO,MACnBC,EAAYD,iBAAO,MAGnBE,EAAO,uCAAG,4BAAAC,EAAA,sEAGIC,MAHJ,OAGRC,EAHQ,OAKbR,EAAKS,aAAY,WAChBC,EAAOF,KACN,IAPW,2CAAH,qDAUPE,EAAM,uCAAG,WAAOF,GAAP,uBAAAF,EAAA,yDAGkB,qBAAtBJ,EAAUS,SACK,OAAtBT,EAAUS,SAC6B,IAAvCT,EAAUS,QAAQhB,MAAMiB,WALb,wBAQLjB,EAAQO,EAAUS,QAAQhB,MAC1BkB,EAAaX,EAAUS,QAAQhB,MAAMkB,WACrCC,EAAcZ,EAAUS,QAAQhB,MAAMmB,YAG5CZ,EAAUS,QAAQhB,MAAMvB,MAAQyC,EAChCX,EAAUS,QAAQhB,MAAMtB,OAASyC,EAGjCV,EAAUO,QAAQvC,MAAQyC,EAC1BT,EAAUO,QAAQtC,OAASyC,EAMrBvD,EAAM6C,EAAUO,QAAQI,WAAW,MAxB9B,UA0BOP,EAAIE,OAAOf,GA1BlB,QA0BLqB,EA1BK,YAkCGjB,KAFdD,EAAQd,EAASgC,EAAKxD,KAIpBkC,EAASC,EAAOG,EAAOvC,EAAKC,GAC5ByD,cAAcjB,KAKbxC,EAAOI,EAAIJ,EAAOM,EAAIsC,EAAUO,QAAQvC,MACzCZ,EAAO0D,IAAM,EACN1D,EAAOI,EAAIJ,EAAOM,EAAI,IAC7BN,EAAO0D,GAAK,GAIX1D,EAAOK,EAAIL,EAAOM,EAAIsC,EAAUO,QAAQtC,OACzCb,EAAO2D,IAAM,EACN3D,EAAOK,EAAIL,EAAOM,EAAI,IAC7BN,EAAO2D,GAAK,GAId3D,EAAOI,EAAIJ,EAAOI,EAAIJ,EAAO0D,GAAG1D,EAAO4D,MACvC5D,EAAOK,EAAIL,EAAOK,EAAIL,EAAO2D,GAAG3D,EAAO4D,MAKvC/D,EAAS2D,EAAKzD,EAAKC,IA9DR,4CAAH,sDAqEZ,OAFA6D,qBAAU,WAAKhB,MAAW,IAGxB,yBAAKiB,UAAU,OACb,4BAAQA,UAAU,cAChB,kBAAC,IAAD,CACEC,IAAKrB,EACLsB,OAAO,EACPC,MAAO,CACLC,SAAU,WACVC,WAAY,OACZC,YAAa,OACbC,KAAM,EACNC,MAAO,EACPC,UAAW,SACXC,OAAQ,EACR5D,MAAO,IACPC,OAAQ,OAIZ,4BACEkD,IAAKnB,EACLqB,MAAO,CACLC,SAAU,WACVC,WAAY,OACZC,YAAa,OACbC,KAAM,EACNC,MAAO,EACPC,UAAW,SACXC,OAAQ,EACR5D,MAAO,IACPC,OAAQ,UC7HpB4D,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,W","file":"static/js/main.77128ac4.chunk.js","sourcesContent":["export const drawRect = (detections, ctx, circle) => {\n    \n    ctx.fillStyle = '#FF000080';\n    ctx.beginPath();\n    ctx.arc(circle.x, circle.y, circle.r, 0, 2*Math.PI, 0);\n    ctx.fill();\n    \n    detections.forEach(prediction=>{\n        //resultados predicciones\n        const [x, y, width, height] = prediction['bbox'];\n        const text = prediction['class'];\n        const score = Math.floor(prediction['score']*100);\n        \n        //estilo cuadrado\n        const color = 'green';\n        ctx.strokeStyle = color;\n        ctx.font = '18px Arial';\n        ctx.fillStyle = color;\n\n        //dibujar\n        ctx.beginPath();\n        ctx.scale(-1,1);\n        ctx.fillText(text +' '+ score + '%', -width-x, y);\n        ctx.scale(-1,1);\n        ctx.lineWidth = 3;\n        ctx.rect(x, y, width, height);\n        ctx.stroke();\n    });\n}\n\nexport const colision = (detections, circle)=>{\n    for (let elem of detections){\n        if(elem['class'] === 'person' && elem['score'] > 0.5){\n            let rx = elem['bbox'][0];\n            let ry = elem['bbox'][1];\n            let rw = elem['bbox'][2];\n            let rh = elem['bbox'][3];\n            let testX = circle.x;\n            let testY = circle.y;\n        \n            if (circle.x < rx){\n                testX = rx;\n               // console.log('cerca de izquierda');\n            }            // test left edge\n            else if (circle.x > rx+rw){ \n                testX = rx+rw;\n               // console.log('cerca de derecha');\n            }   // right edge\n            if (circle.y < ry){\n                testY = ry; \n               // console.log('cerca de arriba');\n                }     // top edge\n            else if (circle.y > ry+rh) {\n                testY = ry+rh;\n                //console.log('cerca de abajo');\n            }   // bottom edge\n        \n            let distance = Math.sqrt( Math.pow((circle.x-testX), 2) + Math.pow((circle.y-testY), 2) );\n            //console.log('Distance:',distance, 'radio:', circle.r);\n            if(distance+35 < circle.r){\n               return elem;\n            }    \n        }\n    }\n    return undefined;\n}\n\nexport const drawLose = (video, box, ctx, circle) => {\n    ctx.drawImage(video, 0, 0);\n    const [x, y, width, height] = box['bbox'];\n    //estilo cuadrado\n    const color = 'red';\n    ctx.strokeStyle = color;\n    ctx.font = '30px bold Arial';\n    ctx.fillStyle = color;\n    //dibujar\n    ctx.beginPath();\n    ctx.scale(-1,1);\n    ctx.fillText('Â¡Toque!', -x-width, y-5);\n    ctx.scale(-1,1);\n    ctx.lineWidth = 3;\n    ctx.rect(x, y, width, height);\n    ctx.stroke();\n\n    ctx.fillStyle = '#FF000080';\n    ctx.beginPath();\n    ctx.arc(circle.x, circle.y, circle.r, 0, 2*Math.PI, 0);\n    ctx.fill();\n\n}","// Import dependencies\nimport React, { useRef, useState, useEffect } from \"react\";\nimport * as tf from \"@tensorflow/tfjs\";\n// 1. TODO - Import required model here\n// e.g. import * as tfmodel from \"@tensorflow-models/tfmodel\";\nimport * as cocossd from \"@tensorflow-models/coco-ssd\"\nimport Webcam from \"react-webcam\";\nimport \"./App.css\";\n// 2. TODO - Import drawing utility here\nimport { drawRect, colision, drawLose } from \"./utilities\";\n\n//Game variables\nvar toque = undefined;\nvar id = undefined;\nvar circle = {'x': 0, 'y':0, 'r':80, 'dx':1, 'dy':1, 'speed':20};\n\nfunction App() {\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n\n  // Main function\n  const runCoco = async () => {\n    // 3. TODO - Load network \n    // e.g. const net = await cocossd.load();\n    const net = await cocossd.load();\n    //  Loop and detect hands\n     id = setInterval(() => {\n      detect(net);\n    }, 10);\n  };\n\n  const detect = async (net) => {\n    // Check data is available\n    if (\n      typeof webcamRef.current !== \"undefined\" &&\n      webcamRef.current !== null &&\n      webcamRef.current.video.readyState === 4\n    ) {\n      // Get Video Properties\n      const video = webcamRef.current.video;\n      const videoWidth = webcamRef.current.video.videoWidth;\n      const videoHeight = webcamRef.current.video.videoHeight;\n\n      // Set video width\n      webcamRef.current.video.width = videoWidth;\n      webcamRef.current.video.height = videoHeight;\n\n      // Set canvas height and width\n      canvasRef.current.width = videoWidth;\n      canvasRef.current.height = videoHeight;\n\n      // 4. TODO - Make Detections\n      // e.g. const obj = await net.detect(video);\n      \n      // Draw mesh\n      const ctx = canvasRef.current.getContext(\"2d\");\n\n      const obj = await net.detect(video);\n      \n      //console.log(obj);\n\n      //COLISION\n\n      toque = colision(obj, circle);\n\n      if (toque !== undefined){\n        //Hubo colision, se debe mostrar la captura y quedarse ahi.\n        drawLose(video, toque, ctx, circle);\n        clearInterval(id);\n      }else{\n      // --------- MOVIMIENTO CIRCULO EN PANTALLA ---------------\n      \n      //Direccion horizontal:\n      if(circle.x + circle.r > canvasRef.current.width){\n        circle.dx = -1;\n      }else if(circle.x - circle.r < 0){\n        circle.dx = 1;\n      }\n\n      //Direccion vertical:\n      if(circle.y + circle.r > canvasRef.current.height){\n        circle.dy = -1;\n      }else if(circle.y - circle.r < 0){\n        circle.dy = 1;\n      }\n\n      //Actualizar posicion circulo\n      circle.x = circle.x + circle.dx*circle.speed;\n      circle.y = circle.y + circle.dy*circle.speed;\n\n\n\n      // 5. TODO - Update drawing utility\n      drawRect(obj, ctx, circle);\n    }\n    }\n  };\n\n  useEffect(()=>{runCoco()},[]);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <Webcam\n          ref={webcamRef}\n          muted={true} \n          style={{\n            position: \"absolute\",\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            left: 0,\n            right: 0,\n            textAlign: \"center\",\n            zindex: 9,\n            width: 640,\n            height: 480,\n          }}\n        />\n\n        <canvas\n          ref={canvasRef}\n          style={{\n            position: \"absolute\",\n            marginLeft: \"auto\",\n            marginRight: \"auto\",\n            left: 0,\n            right: 0,\n            textAlign: \"center\",\n            zindex: 8,\n            width: 640,\n            height: 480,\n          }}\n        />\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}